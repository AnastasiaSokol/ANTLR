//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g 2017-12-18 12:54:43

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


	using System;
	using ConsoleApplication1;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class testParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ADDOP", "BOOL", "BY", "CHAR", "CLOSEBRACKET", "CLOSEFIGUREBRACKET", "DECLAR", "DIGIT", "DO", "DOUBLEPOINT", "ELSE", "ENDOP", "EXPONENT", "FLOAT", "ID", "IF", "INITIALIZE", "INT", "LETTER", "LOGIC_OP", "MULTOP", "OPENBRACKET", "OPENFIGUREBRACKET", "OPSRAVN", "SPACE", "SWITCH", "WHILE", "WS"
	};
	public const int EOF=-1;
	public const int ADDOP=4;
	public const int BOOL=5;
	public const int BY=6;
	public const int CHAR=7;
	public const int CLOSEBRACKET=8;
	public const int CLOSEFIGUREBRACKET=9;
	public const int DECLAR=10;
	public const int DIGIT=11;
	public const int DO=12;
	public const int DOUBLEPOINT=13;
	public const int ELSE=14;
	public const int ENDOP=15;
	public const int EXPONENT=16;
	public const int FLOAT=17;
	public const int ID=18;
	public const int IF=19;
	public const int INITIALIZE=20;
	public const int INT=21;
	public const int LETTER=22;
	public const int LOGIC_OP=23;
	public const int MULTOP=24;
	public const int OPENBRACKET=25;
	public const int OPENFIGUREBRACKET=26;
	public const int OPSRAVN=27;
	public const int SPACE=28;
	public const int SWITCH=29;
	public const int WHILE=30;
	public const int WS=31;

	public testParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public testParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}

	public override string[] TokenNames { get { return testParser.tokenNames; } }
	public override string GrammarFileName { get { return "D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g"; } }


	  Emitter emitter; 
	  public testParser(ITokenStream input, Emitter emitter)
	  	: this(input) 
	  {
	    this.emitter = emitter;
	  }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_program();
	partial void LeaveRule_program();

	// $ANTLR start "program"
	// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:20:1: public program : ( stmt )+ ;
	[GrammarRule("program")]
	public void program()
	{
		EnterRule_program();
		EnterRule("program", 1);
		TraceIn("program", 1);
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(20, 38);
		try
		{
			// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:20:9: ( ( stmt )+ )
			DebugEnterAlt(1);
			// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:20:11: ( stmt )+
			{
			DebugLocation(20, 11);
			// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:20:11: ( stmt )+
			int cnt1=0;
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==DECLAR||(LA1_0>=ID && LA1_0<=IF)||(LA1_0>=SWITCH && LA1_0<=WHILE)))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch (alt1)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:20:12: stmt
					{
					DebugLocation(20, 12);
					PushFollow(Follow._stmt_in_program39);
					stmt();
					PopFollow();


					}
					break;

				default:
					if (cnt1 >= 1)
						goto loop1;

					EarlyExitException eee1 = new EarlyExitException( 1, input );
					DebugRecognitionException(eee1);
					throw eee1;
				}
				cnt1++;
			}
			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(20, 19);
			emitter.AddHalt();

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("program", 1);
			LeaveRule("program", 1);
			LeaveRule_program();
		}
		DebugLocation(20, 38);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		return;

	}
	// $ANTLR end "program"

	partial void EnterRule_stmt();
	partial void LeaveRule_stmt();

	// $ANTLR start "stmt"
	// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:22:1: public stmt : ( declar_stmt | assign_stmt | cycle_stmt | if_stmt | switch_stmt );
	[GrammarRule("stmt")]
	public void stmt()
	{
		EnterRule_stmt();
		EnterRule("stmt", 2);
		TraceIn("stmt", 2);
		try { DebugEnterRule(GrammarFileName, "stmt");
		DebugLocation(22, 60);
		try
		{
			// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:22:5: ( declar_stmt | assign_stmt | cycle_stmt | if_stmt | switch_stmt )
			int alt2=5;
			try { DebugEnterDecision(2, false);
			switch (input.LA(1))
			{
			case DECLAR:
				{
				alt2 = 1;
				}
				break;
			case ID:
				{
				alt2 = 2;
				}
				break;
			case WHILE:
				{
				alt2 = 3;
				}
				break;
			case IF:
				{
				alt2 = 4;
				}
				break;
			case SWITCH:
				{
				alt2 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:22:7: declar_stmt
				{
				DebugLocation(22, 7);
				PushFollow(Follow._declar_stmt_in_stmt51);
				declar_stmt();
				PopFollow();


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:22:19: assign_stmt
				{
				DebugLocation(22, 19);
				PushFollow(Follow._assign_stmt_in_stmt53);
				assign_stmt();
				PopFollow();


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:22:31: cycle_stmt
				{
				DebugLocation(22, 31);
				PushFollow(Follow._cycle_stmt_in_stmt55);
				cycle_stmt();
				PopFollow();


				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:22:42: if_stmt
				{
				DebugLocation(22, 42);
				PushFollow(Follow._if_stmt_in_stmt57);
				if_stmt();
				PopFollow();


				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:22:50: switch_stmt
				{
				DebugLocation(22, 50);
				PushFollow(Follow._switch_stmt_in_stmt59);
				switch_stmt();
				PopFollow();


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("stmt", 2);
			LeaveRule("stmt", 2);
			LeaveRule_stmt();
		}
		DebugLocation(22, 60);
		} finally { DebugExitRule(GrammarFileName, "stmt"); }
		return;

	}
	// $ANTLR end "stmt"

	partial void EnterRule_declar_stmt();
	partial void LeaveRule_declar_stmt();

	// $ANTLR start "declar_stmt"
	// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:25:1: public declar_stmt : DECLAR SPACE operand ENDOP ;
	[GrammarRule("declar_stmt")]
	public void declar_stmt()
	{
		EnterRule_declar_stmt();
		EnterRule("declar_stmt", 3);
		TraceIn("declar_stmt", 3);
		try { DebugEnterRule(GrammarFileName, "declar_stmt");
		DebugLocation(25, 39);
		try
		{
			// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:25:12: ( DECLAR SPACE operand ENDOP )
			DebugEnterAlt(1);
			// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:25:14: DECLAR SPACE operand ENDOP
			{
			DebugLocation(25, 14);
			Match(input,DECLAR,Follow._DECLAR_in_declar_stmt68); 
			DebugLocation(25, 21);
			Match(input,SPACE,Follow._SPACE_in_declar_stmt70); 
			DebugLocation(25, 27);
			PushFollow(Follow._operand_in_declar_stmt72);
			operand();
			PopFollow();

			DebugLocation(25, 35);
			Match(input,ENDOP,Follow._ENDOP_in_declar_stmt74); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("declar_stmt", 3);
			LeaveRule("declar_stmt", 3);
			LeaveRule_declar_stmt();
		}
		DebugLocation(25, 39);
		} finally { DebugExitRule(GrammarFileName, "declar_stmt"); }
		return;

	}
	// $ANTLR end "declar_stmt"

	partial void EnterRule_assign_stmt();
	partial void LeaveRule_assign_stmt();

	// $ANTLR start "assign_stmt"
	// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:27:1: public assign_stmt : ID INITIALIZE expr ENDOP ;
	[GrammarRule("assign_stmt")]
	public void assign_stmt()
	{
		EnterRule_assign_stmt();
		EnterRule("assign_stmt", 4);
		TraceIn("assign_stmt", 4);
		IToken ID1 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "assign_stmt");
		DebugLocation(27, 104);
		try
		{
			// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:27:12: ( ID INITIALIZE expr ENDOP )
			DebugEnterAlt(1);
			// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:27:14: ID INITIALIZE expr ENDOP
			{
			DebugLocation(27, 14);
			ID1=(IToken)Match(input,ID,Follow._ID_in_assign_stmt82); 
			DebugLocation(27, 18);
			emitter.AddLValue((ID1!=null?ID1.Text:null)); 
			DebugLocation(27, 51);
			Match(input,INITIALIZE,Follow._INITIALIZE_in_assign_stmt88); 
			DebugLocation(27, 63);
			PushFollow(Follow._expr_in_assign_stmt91);
			expr();
			PopFollow();

			DebugLocation(27, 68);
			emitter.AddAssignStatement();
			DebugLocation(27, 100);
			Match(input,ENDOP,Follow._ENDOP_in_assign_stmt95); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("assign_stmt", 4);
			LeaveRule("assign_stmt", 4);
			LeaveRule_assign_stmt();
		}
		DebugLocation(27, 104);
		} finally { DebugExitRule(GrammarFileName, "assign_stmt"); }
		return;

	}
	// $ANTLR end "assign_stmt"

	partial void EnterRule_cycle_stmt();
	partial void LeaveRule_cycle_stmt();

	// $ANTLR start "cycle_stmt"
	// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:31:1: public cycle_stmt : WHILE log_operation DO OPENFIGUREBRACKET stmt_or_block CLOSEFIGUREBRACKET ;
	[GrammarRule("cycle_stmt")]
	public void cycle_stmt()
	{
		EnterRule_cycle_stmt();
		EnterRule("cycle_stmt", 5);
		TraceIn("cycle_stmt", 5);
		try { DebugEnterRule(GrammarFileName, "cycle_stmt");
		DebugLocation(31, 62);
		try
		{
			// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:32:2: ( WHILE log_operation DO OPENFIGUREBRACKET stmt_or_block CLOSEFIGUREBRACKET )
			DebugEnterAlt(1);
			// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:32:5: WHILE log_operation DO OPENFIGUREBRACKET stmt_or_block CLOSEFIGUREBRACKET
			{
			DebugLocation(32, 5);
			Match(input,WHILE,Follow._WHILE_in_cycle_stmt108); 
			DebugLocation(32, 11);
			emitter.Add_Label_Condition();
			DebugLocation(32, 44);
			PushFollow(Follow._log_operation_in_cycle_stmt112);
			log_operation();
			PopFollow();

			DebugLocation(32, 58);
			emitter.Add_GoFalse_End_While();
			DebugLocation(32, 93);
			Match(input,DO,Follow._DO_in_cycle_stmt116); 
			DebugLocation(32, 97);
			Match(input,OPENFIGUREBRACKET,Follow._OPENFIGUREBRACKET_in_cycle_stmt119); 
			DebugLocation(32, 115);
			PushFollow(Follow._stmt_or_block_in_cycle_stmt121);
			stmt_or_block();
			PopFollow();

			DebugLocation(32, 129);
			Match(input,CLOSEFIGUREBRACKET,Follow._CLOSEFIGUREBRACKET_in_cycle_stmt123); 
			DebugLocation(33, 2);
			emitter.Add_Goto_Condition(); emitter.AddLabel_End_While();

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("cycle_stmt", 5);
			LeaveRule("cycle_stmt", 5);
			LeaveRule_cycle_stmt();
		}
		DebugLocation(33, 62);
		} finally { DebugExitRule(GrammarFileName, "cycle_stmt"); }
		return;

	}
	// $ANTLR end "cycle_stmt"

	partial void EnterRule_if_stmt();
	partial void LeaveRule_if_stmt();

	// $ANTLR start "if_stmt"
	// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:38:1: public if_stmt : IF log_operation OPENFIGUREBRACKET stmt_or_block CLOSEFIGUREBRACKET ( ELSE OPENFIGUREBRACKET stmt_or_block CLOSEFIGUREBRACKET )? ;
	[GrammarRule("if_stmt")]
	public void if_stmt()
	{
		EnterRule_if_stmt();
		EnterRule("if_stmt", 6);
		TraceIn("if_stmt", 6);
		try { DebugEnterRule(GrammarFileName, "if_stmt");
		DebugLocation(38, 1);
		try
		{
			// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:38:9: ( IF log_operation OPENFIGUREBRACKET stmt_or_block CLOSEFIGUREBRACKET ( ELSE OPENFIGUREBRACKET stmt_or_block CLOSEFIGUREBRACKET )? )
			DebugEnterAlt(1);
			// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:38:11: IF log_operation OPENFIGUREBRACKET stmt_or_block CLOSEFIGUREBRACKET ( ELSE OPENFIGUREBRACKET stmt_or_block CLOSEFIGUREBRACKET )?
			{
			DebugLocation(38, 11);
			Match(input,IF,Follow._IF_in_if_stmt139); 
			DebugLocation(38, 14);
			PushFollow(Follow._log_operation_in_if_stmt141);
			log_operation();
			PopFollow();

			DebugLocation(38, 28);
			emitter.Add_GoFalse_Else_or_EndIf();
			DebugLocation(38, 67);
			Match(input,OPENFIGUREBRACKET,Follow._OPENFIGUREBRACKET_in_if_stmt145); 
			DebugLocation(38, 85);
			PushFollow(Follow._stmt_or_block_in_if_stmt147);
			stmt_or_block();
			PopFollow();

			DebugLocation(38, 99);
			Match(input,CLOSEFIGUREBRACKET,Follow._CLOSEFIGUREBRACKET_in_if_stmt149); 
			DebugLocation(38, 118);
			emitter.Add_Label_Else_or_EndIf();
			DebugLocation(38, 155);
			// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:38:155: ( ELSE OPENFIGUREBRACKET stmt_or_block CLOSEFIGUREBRACKET )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_0 = input.LA(1);

			if ((LA3_0==ELSE))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:38:156: ELSE OPENFIGUREBRACKET stmt_or_block CLOSEFIGUREBRACKET
				{
				DebugLocation(38, 156);
				Match(input,ELSE,Follow._ELSE_in_if_stmt154); 
				DebugLocation(38, 161);
				Match(input,OPENFIGUREBRACKET,Follow._OPENFIGUREBRACKET_in_if_stmt156); 
				DebugLocation(38, 179);
				PushFollow(Follow._stmt_or_block_in_if_stmt158);
				stmt_or_block();
				PopFollow();

				DebugLocation(38, 193);
				Match(input,CLOSEFIGUREBRACKET,Follow._CLOSEFIGUREBRACKET_in_if_stmt160); 
				DebugLocation(38, 212);
				emitter.Add_Label_EndElse();

				}
				break;

			}
			} finally { DebugExitSubRule(3); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("if_stmt", 6);
			LeaveRule("if_stmt", 6);
			LeaveRule_if_stmt();
		}
		DebugLocation(39, 1);
		} finally { DebugExitRule(GrammarFileName, "if_stmt"); }
		return;

	}
	// $ANTLR end "if_stmt"

	partial void EnterRule_switch_stmt();
	partial void LeaveRule_switch_stmt();

	// $ANTLR start "switch_stmt"
	// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:42:1: public switch_stmt : SWITCH ID OPENFIGUREBRACKET ( cases )+ CLOSEFIGUREBRACKET ;
	[GrammarRule("switch_stmt")]
	public void switch_stmt()
	{
		EnterRule_switch_stmt();
		EnterRule("switch_stmt", 7);
		TraceIn("switch_stmt", 7);
		IToken ID2 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "switch_stmt");
		DebugLocation(42, 90);
		try
		{
			// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:43:2: ( SWITCH ID OPENFIGUREBRACKET ( cases )+ CLOSEFIGUREBRACKET )
			DebugEnterAlt(1);
			// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:43:3: SWITCH ID OPENFIGUREBRACKET ( cases )+ CLOSEFIGUREBRACKET
			{
			DebugLocation(43, 3);
			Match(input,SWITCH,Follow._SWITCH_in_switch_stmt176); 
			DebugLocation(43, 10);
			ID2=(IToken)Match(input,ID,Follow._ID_in_switch_stmt178); 
			DebugLocation(43, 13);
			Match(input,OPENFIGUREBRACKET,Follow._OPENFIGUREBRACKET_in_switch_stmt180); 
			DebugLocation(43, 31);
			// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:43:31: ( cases )+
			int cnt4=0;
			try { DebugEnterSubRule(4);
			while (true)
			{
				int alt4=2;
				try { DebugEnterDecision(4, false);
				int LA4_0 = input.LA(1);

				if ((LA4_0==BY))
				{
					alt4 = 1;
				}


				} finally { DebugExitDecision(4); }
				switch (alt4)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:43:33: cases
					{
					DebugLocation(43, 33);
					emitter.AddLoadID((ID2!=null?ID2.Text:null)); 
					DebugLocation(43, 65);
					PushFollow(Follow._cases_in_switch_stmt186);
					cases();
					PopFollow();


					}
					break;

				default:
					if (cnt4 >= 1)
						goto loop4;

					EarlyExitException eee4 = new EarlyExitException( 4, input );
					DebugRecognitionException(eee4);
					throw eee4;
				}
				cnt4++;
			}
			loop4:
				;

			} finally { DebugExitSubRule(4); }

			DebugLocation(43, 73);
			Match(input,CLOSEFIGUREBRACKET,Follow._CLOSEFIGUREBRACKET_in_switch_stmt190); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("switch_stmt", 7);
			LeaveRule("switch_stmt", 7);
			LeaveRule_switch_stmt();
		}
		DebugLocation(43, 90);
		} finally { DebugExitRule(GrammarFileName, "switch_stmt"); }
		return;

	}
	// $ANTLR end "switch_stmt"

	partial void EnterRule_cases();
	partial void LeaveRule_cases();

	// $ANTLR start "cases"
	// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:45:1: public cases : BY const DOUBLEPOINT stmt_or_block ;
	[GrammarRule("cases")]
	public void cases()
	{
		EnterRule_cases();
		EnterRule("cases", 8);
		TraceIn("cases", 8);
		String const3 = default(String);

		try { DebugEnterRule(GrammarFileName, "cases");
		DebugLocation(45, 1);
		try
		{
			// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:45:7: ( BY const DOUBLEPOINT stmt_or_block )
			DebugEnterAlt(1);
			// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:45:9: BY const DOUBLEPOINT stmt_or_block
			{
			DebugLocation(45, 9);
			Match(input,BY,Follow._BY_in_cases199); 
			DebugLocation(45, 13);
			PushFollow(Follow._const_in_cases202);
			const3=@const();
			PopFollow();

			DebugLocation(45, 19);
			emitter.AddLoadConst(const3); emitter.AddEq(); emitter.AddGOFALSE_END_CASE(); 
			DebugLocation(45, 106);
			Match(input,DOUBLEPOINT,Follow._DOUBLEPOINT_in_cases206); 
			DebugLocation(45, 118);
			PushFollow(Follow._stmt_or_block_in_cases208);
			stmt_or_block();
			PopFollow();

			DebugLocation(45, 132);
			emitter.AddLABEL_END_CASE();

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("cases", 8);
			LeaveRule("cases", 8);
			LeaveRule_cases();
		}
		DebugLocation(46, 1);
		} finally { DebugExitRule(GrammarFileName, "cases"); }
		return;

	}
	// $ANTLR end "cases"

	partial void EnterRule_term();
	partial void LeaveRule_term();

	// $ANTLR start "term"
	// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:52:1: term : ( OPENBRACKET factor MULTOP factor CLOSEBRACKET | factor );
	[GrammarRule("term")]
	private void term()
	{
		EnterRule_term();
		EnterRule("term", 9);
		TraceIn("term", 9);
		IToken MULTOP4 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "term");
		DebugLocation(52, 11);
		try
		{
			// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:52:7: ( OPENBRACKET factor MULTOP factor CLOSEBRACKET | factor )
			int alt5=2;
			try { DebugEnterDecision(5, false);
			int LA5_0 = input.LA(1);

			if ((LA5_0==OPENBRACKET))
			{
				alt5 = 1;
			}
			else if ((LA5_0==BOOL||LA5_0==CHAR||(LA5_0>=FLOAT && LA5_0<=ID)||LA5_0==INT))
			{
				alt5 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 5, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:52:9: OPENBRACKET factor MULTOP factor CLOSEBRACKET
				{
				DebugLocation(52, 9);
				Match(input,OPENBRACKET,Follow._OPENBRACKET_in_term225); 
				DebugLocation(52, 21);
				PushFollow(Follow._factor_in_term227);
				factor();
				PopFollow();

				DebugLocation(52, 28);
				MULTOP4=(IToken)Match(input,MULTOP,Follow._MULTOP_in_term229); 
				DebugLocation(52, 35);
				PushFollow(Follow._factor_in_term231);
				factor();
				PopFollow();

				DebugLocation(52, 42);
				emitter.AddOperation((MULTOP4!=null?MULTOP4.Text:null));
				DebugLocation(52, 81);
				Match(input,CLOSEBRACKET,Follow._CLOSEBRACKET_in_term236); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:53:5: factor
				{
				DebugLocation(53, 5);
				PushFollow(Follow._factor_in_term242);
				factor();
				PopFollow();


				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("term", 9);
			LeaveRule("term", 9);
			LeaveRule_term();
		}
		DebugLocation(53, 11);
		} finally { DebugExitRule(GrammarFileName, "term"); }
		return;

	}
	// $ANTLR end "term"

	partial void EnterRule_factor();
	partial void LeaveRule_factor();

	// $ANTLR start "factor"
	// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:54:1: factor : operand ;
	[GrammarRule("factor")]
	private void factor()
	{
		EnterRule_factor();
		EnterRule("factor", 10);
		TraceIn("factor", 10);
		try { DebugEnterRule(GrammarFileName, "factor");
		DebugLocation(54, 17);
		try
		{
			// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:54:8: ( operand )
			DebugEnterAlt(1);
			// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:54:11: operand
			{
			DebugLocation(54, 11);
			PushFollow(Follow._operand_in_factor251);
			operand();
			PopFollow();


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("factor", 10);
			LeaveRule("factor", 10);
			LeaveRule_factor();
		}
		DebugLocation(54, 17);
		} finally { DebugExitRule(GrammarFileName, "factor"); }
		return;

	}
	// $ANTLR end "factor"

	partial void EnterRule_expr();
	partial void LeaveRule_expr();

	// $ANTLR start "expr"
	// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:55:1: expr : ( term | OPENBRACKET term ADDOP term CLOSEBRACKET );
	[GrammarRule("expr")]
	private void expr()
	{
		EnterRule_expr();
		EnterRule("expr", 11);
		TraceIn("expr", 11);
		IToken ADDOP5 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(55, 1);
		try
		{
			// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:55:6: ( term | OPENBRACKET term ADDOP term CLOSEBRACKET )
			int alt6=2;
			try { DebugEnterDecision(6, false);
			int LA6_0 = input.LA(1);

			if ((LA6_0==OPENBRACKET))
			{
				switch (input.LA(2))
				{
				case ID:
					{
					int LA6_3 = input.LA(3);

					if ((LA6_3==MULTOP))
					{
						alt6 = 1;
					}
					else if ((LA6_3==ADDOP))
					{
						alt6 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 6, 3, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case INT:
					{
					int LA6_4 = input.LA(3);

					if ((LA6_4==MULTOP))
					{
						alt6 = 1;
					}
					else if ((LA6_4==ADDOP))
					{
						alt6 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 6, 4, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case FLOAT:
					{
					int LA6_5 = input.LA(3);

					if ((LA6_5==MULTOP))
					{
						alt6 = 1;
					}
					else if ((LA6_5==ADDOP))
					{
						alt6 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 6, 5, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case CHAR:
					{
					int LA6_6 = input.LA(3);

					if ((LA6_6==MULTOP))
					{
						alt6 = 1;
					}
					else if ((LA6_6==ADDOP))
					{
						alt6 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 6, 6, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case BOOL:
					{
					int LA6_7 = input.LA(3);

					if ((LA6_7==MULTOP))
					{
						alt6 = 1;
					}
					else if ((LA6_7==ADDOP))
					{
						alt6 = 2;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 6, 7, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case OPENBRACKET:
					{
					alt6 = 2;
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 6, 1, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

			}
			else if ((LA6_0==BOOL||LA6_0==CHAR||(LA6_0>=FLOAT && LA6_0<=ID)||LA6_0==INT))
			{
				alt6 = 1;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 6, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:55:8: term
				{
				DebugLocation(55, 8);
				PushFollow(Follow._term_in_expr258);
				term();
				PopFollow();


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:56:10: OPENBRACKET term ADDOP term CLOSEBRACKET
				{
				DebugLocation(56, 10);
				Match(input,OPENBRACKET,Follow._OPENBRACKET_in_expr271); 
				DebugLocation(56, 22);
				PushFollow(Follow._term_in_expr273);
				term();
				PopFollow();

				DebugLocation(56, 29);
				ADDOP5=(IToken)Match(input,ADDOP,Follow._ADDOP_in_expr277); 
				DebugLocation(56, 37);
				PushFollow(Follow._term_in_expr281);
				term();
				PopFollow();

				DebugLocation(56, 42);
				emitter.AddOperation((ADDOP5!=null?ADDOP5.Text:null));
				DebugLocation(56, 78);
				Match(input,CLOSEBRACKET,Follow._CLOSEBRACKET_in_expr284); 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("expr", 11);
			LeaveRule("expr", 11);
			LeaveRule_expr();
		}
		DebugLocation(57, 1);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return;

	}
	// $ANTLR end "expr"

	partial void EnterRule_operand();
	partial void LeaveRule_operand();

	// $ANTLR start "operand"
	// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:59:1: operand : ( ID | const );
	[GrammarRule("operand")]
	private void operand()
	{
		EnterRule_operand();
		EnterRule("operand", 12);
		TraceIn("operand", 12);
		IToken ID6 = default(IToken);
		String const7 = default(String);

		try { DebugEnterRule(GrammarFileName, "operand");
		DebugLocation(59, 89);
		try
		{
			// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:59:9: ( ID | const )
			int alt7=2;
			try { DebugEnterDecision(7, false);
			int LA7_0 = input.LA(1);

			if ((LA7_0==ID))
			{
				alt7 = 1;
			}
			else if ((LA7_0==BOOL||LA7_0==CHAR||LA7_0==FLOAT||LA7_0==INT))
			{
				alt7 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 7, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:59:11: ID
				{
				DebugLocation(59, 11);
				ID6=(IToken)Match(input,ID,Follow._ID_in_operand296); 
				DebugLocation(59, 14);
				emitter.AddLoadID((ID6!=null?ID6.Text:null)); 

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:59:47: const
				{
				DebugLocation(59, 47);
				PushFollow(Follow._const_in_operand301);
				const7=@const();
				PopFollow();

				DebugLocation(59, 52);
				emitter.AddLoadConst(const7); 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("operand", 12);
			LeaveRule("operand", 12);
			LeaveRule_operand();
		}
		DebugLocation(59, 89);
		} finally { DebugExitRule(GrammarFileName, "operand"); }
		return;

	}
	// $ANTLR end "operand"

	partial void EnterRule_stmt_or_block();
	partial void LeaveRule_stmt_or_block();

	// $ANTLR start "stmt_or_block"
	// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:63:1: stmt_or_block : ( stmt | OPENFIGUREBRACKET stmt CLOSEFIGUREBRACKET );
	[GrammarRule("stmt_or_block")]
	private void stmt_or_block()
	{
		EnterRule_stmt_or_block();
		EnterRule("stmt_or_block", 13);
		TraceIn("stmt_or_block", 13);
		try { DebugEnterRule(GrammarFileName, "stmt_or_block");
		DebugLocation(63, 52);
		try
		{
			// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:64:2: ( stmt | OPENFIGUREBRACKET stmt CLOSEFIGUREBRACKET )
			int alt8=2;
			try { DebugEnterDecision(8, false);
			int LA8_0 = input.LA(1);

			if ((LA8_0==DECLAR||(LA8_0>=ID && LA8_0<=IF)||(LA8_0>=SWITCH && LA8_0<=WHILE)))
			{
				alt8 = 1;
			}
			else if ((LA8_0==OPENFIGUREBRACKET))
			{
				alt8 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 8, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:64:5: stmt
				{
				DebugLocation(64, 5);
				PushFollow(Follow._stmt_in_stmt_or_block314);
				stmt();
				PopFollow();


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:64:12: OPENFIGUREBRACKET stmt CLOSEFIGUREBRACKET
				{
				DebugLocation(64, 12);
				Match(input,OPENFIGUREBRACKET,Follow._OPENFIGUREBRACKET_in_stmt_or_block318); 
				DebugLocation(64, 30);
				PushFollow(Follow._stmt_in_stmt_or_block320);
				stmt();
				PopFollow();

				DebugLocation(64, 35);
				Match(input,CLOSEFIGUREBRACKET,Follow._CLOSEFIGUREBRACKET_in_stmt_or_block322); 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("stmt_or_block", 13);
			LeaveRule("stmt_or_block", 13);
			LeaveRule_stmt_or_block();
		}
		DebugLocation(64, 52);
		} finally { DebugExitRule(GrammarFileName, "stmt_or_block"); }
		return;

	}
	// $ANTLR end "stmt_or_block"

	partial void EnterRule_log_operation();
	partial void LeaveRule_log_operation();

	// $ANTLR start "log_operation"
	// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:66:1: log_operation : ( operand | OPENBRACKET operand LOGIC_OP operand CLOSEBRACKET | OPENBRACKET operand OPSRAVN operand CLOSEBRACKET );
	[GrammarRule("log_operation")]
	private void log_operation()
	{
		EnterRule_log_operation();
		EnterRule("log_operation", 14);
		TraceIn("log_operation", 14);
		IToken LOGIC_OP8 = default(IToken);
		IToken OPSRAVN9 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "log_operation");
		DebugLocation(66, 1);
		try
		{
			// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:67:2: ( operand | OPENBRACKET operand LOGIC_OP operand CLOSEBRACKET | OPENBRACKET operand OPSRAVN operand CLOSEBRACKET )
			int alt9=3;
			try { DebugEnterDecision(9, false);
			int LA9_0 = input.LA(1);

			if ((LA9_0==BOOL||LA9_0==CHAR||(LA9_0>=FLOAT && LA9_0<=ID)||LA9_0==INT))
			{
				alt9 = 1;
			}
			else if ((LA9_0==OPENBRACKET))
			{
				switch (input.LA(2))
				{
				case ID:
					{
					int LA9_3 = input.LA(3);

					if ((LA9_3==LOGIC_OP))
					{
						alt9 = 2;
					}
					else if ((LA9_3==OPSRAVN))
					{
						alt9 = 3;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 9, 3, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case INT:
					{
					int LA9_4 = input.LA(3);

					if ((LA9_4==LOGIC_OP))
					{
						alt9 = 2;
					}
					else if ((LA9_4==OPSRAVN))
					{
						alt9 = 3;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 9, 4, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case FLOAT:
					{
					int LA9_5 = input.LA(3);

					if ((LA9_5==LOGIC_OP))
					{
						alt9 = 2;
					}
					else if ((LA9_5==OPSRAVN))
					{
						alt9 = 3;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 9, 5, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case CHAR:
					{
					int LA9_6 = input.LA(3);

					if ((LA9_6==LOGIC_OP))
					{
						alt9 = 2;
					}
					else if ((LA9_6==OPSRAVN))
					{
						alt9 = 3;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 9, 6, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				case BOOL:
					{
					int LA9_7 = input.LA(3);

					if ((LA9_7==LOGIC_OP))
					{
						alt9 = 2;
					}
					else if ((LA9_7==OPSRAVN))
					{
						alt9 = 3;
					}
					else
					{
						NoViableAltException nvae = new NoViableAltException("", 9, 7, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
					}
					break;
				default:
					{
						NoViableAltException nvae = new NoViableAltException("", 9, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 9, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:67:4: operand
				{
				DebugLocation(67, 4);
				PushFollow(Follow._operand_in_log_operation331);
				operand();
				PopFollow();


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:68:4: OPENBRACKET operand LOGIC_OP operand CLOSEBRACKET
				{
				DebugLocation(68, 4);
				Match(input,OPENBRACKET,Follow._OPENBRACKET_in_log_operation336); 
				DebugLocation(68, 16);
				PushFollow(Follow._operand_in_log_operation338);
				operand();
				PopFollow();

				DebugLocation(68, 24);
				LOGIC_OP8=(IToken)Match(input,LOGIC_OP,Follow._LOGIC_OP_in_log_operation340); 
				DebugLocation(68, 35);
				PushFollow(Follow._operand_in_log_operation344);
				operand();
				PopFollow();

				DebugLocation(68, 43);
				emitter.AddOperation((LOGIC_OP8!=null?LOGIC_OP8.Text:null));
				DebugLocation(68, 82);
				Match(input,CLOSEBRACKET,Follow._CLOSEBRACKET_in_log_operation347); 

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:69:4: OPENBRACKET operand OPSRAVN operand CLOSEBRACKET
				{
				DebugLocation(69, 4);
				Match(input,OPENBRACKET,Follow._OPENBRACKET_in_log_operation352); 
				DebugLocation(69, 16);
				PushFollow(Follow._operand_in_log_operation354);
				operand();
				PopFollow();

				DebugLocation(69, 24);
				OPSRAVN9=(IToken)Match(input,OPSRAVN,Follow._OPSRAVN_in_log_operation356); 
				DebugLocation(69, 32);
				PushFollow(Follow._operand_in_log_operation358);
				operand();
				PopFollow();

				DebugLocation(69, 40);
				emitter.AddOperation((OPSRAVN9!=null?OPSRAVN9.Text:null));
				DebugLocation(69, 78);
				Match(input,CLOSEBRACKET,Follow._CLOSEBRACKET_in_log_operation361); 

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("log_operation", 14);
			LeaveRule("log_operation", 14);
			LeaveRule_log_operation();
		}
		DebugLocation(70, 1);
		} finally { DebugExitRule(GrammarFileName, "log_operation"); }
		return;

	}
	// $ANTLR end "log_operation"

	partial void EnterRule_const();
	partial void LeaveRule_const();

	// $ANTLR start "const"
	// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:72:1: const returns [String value] : ( INT | FLOAT | CHAR | BOOL );
	[GrammarRule("const")]
	private String @const()
	{
		EnterRule_const();
		EnterRule("const", 15);
		TraceIn("const", 15);
		String value = default(String);


		IToken INT10 = default(IToken);
		IToken FLOAT11 = default(IToken);
		IToken CHAR12 = default(IToken);
		IToken BOOL13 = default(IToken);

		try { DebugEnterRule(GrammarFileName, "const");
		DebugLocation(72, 1);
		try
		{
			// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:72:28: ( INT | FLOAT | CHAR | BOOL )
			int alt10=4;
			try { DebugEnterDecision(10, false);
			switch (input.LA(1))
			{
			case INT:
				{
				alt10 = 1;
				}
				break;
			case FLOAT:
				{
				alt10 = 2;
				}
				break;
			case CHAR:
				{
				alt10 = 3;
				}
				break;
			case BOOL:
				{
				alt10 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 10, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:73:3: INT
				{
				DebugLocation(73, 3);
				INT10=(IToken)Match(input,INT,Follow._INT_in_const376); 
				DebugLocation(73, 6);
                            value = (INT10 != null ? INT10.Text : null);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:74:4: FLOAT
				{
				DebugLocation(74, 4);
				FLOAT11=(IToken)Match(input,FLOAT,Follow._FLOAT_in_const382); 
				DebugLocation(74, 9);
                            value = (FLOAT11 != null ? FLOAT11.Text : null);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:75:4: CHAR
				{
				DebugLocation(75, 4);
				CHAR12=(IToken)Match(input,CHAR,Follow._CHAR_in_const388); 
				DebugLocation(75, 8);
                            value = (CHAR12 != null ? CHAR12.Text : null);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\1 NDATA(05.07.16)\\!_SOKOLOVA_!\\!_SEMESTR_7!\\LABS\\TIPS\\курсоваяANTLR_Соколова\\test.g:76:4: BOOL
				{
				DebugLocation(76, 4);
				BOOL13=(IToken)Match(input,BOOL,Follow._BOOL_in_const394); 
				DebugLocation(76, 8);
                            value = (BOOL13 != null ? BOOL13.Text : null);

				}
				break;

			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("const", 15);
			LeaveRule("const", 15);
			LeaveRule_const();
		}
		DebugLocation(77, 1);
		} finally { DebugExitRule(GrammarFileName, "const"); }
		return value;

	}
	// $ANTLR end "const"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _stmt_in_program39 = new BitSet(new ulong[]{0x600C0402UL});
		public static readonly BitSet _declar_stmt_in_stmt51 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assign_stmt_in_stmt53 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _cycle_stmt_in_stmt55 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _if_stmt_in_stmt57 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _switch_stmt_in_stmt59 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DECLAR_in_declar_stmt68 = new BitSet(new ulong[]{0x10000000UL});
		public static readonly BitSet _SPACE_in_declar_stmt70 = new BitSet(new ulong[]{0x2600A0UL});
		public static readonly BitSet _operand_in_declar_stmt72 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _ENDOP_in_declar_stmt74 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_assign_stmt82 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _INITIALIZE_in_assign_stmt88 = new BitSet(new ulong[]{0x22600A0UL});
		public static readonly BitSet _expr_in_assign_stmt91 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _ENDOP_in_assign_stmt95 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_cycle_stmt108 = new BitSet(new ulong[]{0x22600A0UL});
		public static readonly BitSet _log_operation_in_cycle_stmt112 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _DO_in_cycle_stmt116 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _OPENFIGUREBRACKET_in_cycle_stmt119 = new BitSet(new ulong[]{0x640C0400UL});
		public static readonly BitSet _stmt_or_block_in_cycle_stmt121 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _CLOSEFIGUREBRACKET_in_cycle_stmt123 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_in_if_stmt139 = new BitSet(new ulong[]{0x22600A0UL});
		public static readonly BitSet _log_operation_in_if_stmt141 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _OPENFIGUREBRACKET_in_if_stmt145 = new BitSet(new ulong[]{0x640C0400UL});
		public static readonly BitSet _stmt_or_block_in_if_stmt147 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _CLOSEFIGUREBRACKET_in_if_stmt149 = new BitSet(new ulong[]{0x4002UL});
		public static readonly BitSet _ELSE_in_if_stmt154 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _OPENFIGUREBRACKET_in_if_stmt156 = new BitSet(new ulong[]{0x640C0400UL});
		public static readonly BitSet _stmt_or_block_in_if_stmt158 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _CLOSEFIGUREBRACKET_in_if_stmt160 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _SWITCH_in_switch_stmt176 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _ID_in_switch_stmt178 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _OPENFIGUREBRACKET_in_switch_stmt180 = new BitSet(new ulong[]{0x40UL});
		public static readonly BitSet _cases_in_switch_stmt186 = new BitSet(new ulong[]{0x240UL});
		public static readonly BitSet _CLOSEFIGUREBRACKET_in_switch_stmt190 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BY_in_cases199 = new BitSet(new ulong[]{0x2200A0UL});
		public static readonly BitSet _const_in_cases202 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _DOUBLEPOINT_in_cases206 = new BitSet(new ulong[]{0x640C0400UL});
		public static readonly BitSet _stmt_or_block_in_cases208 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OPENBRACKET_in_term225 = new BitSet(new ulong[]{0x2600A0UL});
		public static readonly BitSet _factor_in_term227 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _MULTOP_in_term229 = new BitSet(new ulong[]{0x2600A0UL});
		public static readonly BitSet _factor_in_term231 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _CLOSEBRACKET_in_term236 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _factor_in_term242 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _operand_in_factor251 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _term_in_expr258 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OPENBRACKET_in_expr271 = new BitSet(new ulong[]{0x22600A0UL});
		public static readonly BitSet _term_in_expr273 = new BitSet(new ulong[]{0x10UL});
		public static readonly BitSet _ADDOP_in_expr277 = new BitSet(new ulong[]{0x22600A0UL});
		public static readonly BitSet _term_in_expr281 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _CLOSEBRACKET_in_expr284 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_operand296 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _const_in_operand301 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _stmt_in_stmt_or_block314 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OPENFIGUREBRACKET_in_stmt_or_block318 = new BitSet(new ulong[]{0x600C0400UL});
		public static readonly BitSet _stmt_in_stmt_or_block320 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _CLOSEFIGUREBRACKET_in_stmt_or_block322 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _operand_in_log_operation331 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OPENBRACKET_in_log_operation336 = new BitSet(new ulong[]{0x2600A0UL});
		public static readonly BitSet _operand_in_log_operation338 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _LOGIC_OP_in_log_operation340 = new BitSet(new ulong[]{0x2600A0UL});
		public static readonly BitSet _operand_in_log_operation344 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _CLOSEBRACKET_in_log_operation347 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _OPENBRACKET_in_log_operation352 = new BitSet(new ulong[]{0x2600A0UL});
		public static readonly BitSet _operand_in_log_operation354 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _OPSRAVN_in_log_operation356 = new BitSet(new ulong[]{0x2600A0UL});
		public static readonly BitSet _operand_in_log_operation358 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _CLOSEBRACKET_in_log_operation361 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _INT_in_const376 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FLOAT_in_const382 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _CHAR_in_const388 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BOOL_in_const394 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
